; this source file handles reading note data and SMCing certain bytes in bitbang.z80 to change what notes are playing
; the general-purpose driver, ch_driver, is relocatable
;  it gets copied to RAM on start four times, the drumbass driver is appended once, this drumbass driver will also wait for the next frame and jump back to the first general-purpose driver
;   relocate_a are addresses within the driver itself (org $0000 is assumed)
;   relocate_w are addresses inside the pulsewave bitbang routines (thus depending on the channel)
; the drumbass driver, db_driver, is not relocatable, its origin is assumed to be driver_ram + 4 * driver.size

macro driver_init
  local driver_init_c

driver_init_c:
  ld ixl,4                    ; repeat 4 times; one for each general-purpose channel
  ld de,driver_ram            ; DE holds the current pointer address

.loop:
  ld a,ixl
  cp 2
  jq nz,.not_middle_insert_drum

  ld hl,drumbass
  ld bc,drumbass.size
  ldir
.not_middle_insert_drum:

  push de                     ; DE will be destroyed

  ld hl,ch_driver
  ld bc,ch_driver.size
  ldir

  pop bc                      ; get the start of the channel back (into BC), and store the end of the channel
  push de
  ld ixh,relocate_a.len       ; iterate over relocate_a
  ld hl,relocate_a.table
.relocate_a_loop:
  ld e,[hl]                   ; read the offset from the table
  inc hl                      ; and advance pointer
  ld d,[hl]
  inc hl
  ex de,hl
  add hl,bc                   ; calculate word address

  ld a,c                      ; add offset to word
  add a,[hl]
  ld [hl],a
  inc hl
  ld a,b
  adc a,[hl]
  ld [hl],a

  dec ixh                     ; repeat
  ex de,hl
  jq nz,.relocate_a_loop


  ld a,4                      ; get the iterator as 0-3 (instead of 4-1)
  sub ixl
  add a,a                     ; multiply by 20 (size of general-purpose pulsewave bitbang routine)
  add a,a
  ld e,a
  add a,a
  add a,a
  add a,e
  ld iyl,a                    ; keep in IYL

  ld ixh,relocate_w.len       ; iterate over relocate_w
  ld hl,relocate_w.table
.relocate_w_loop:
  ld e,[hl]                   ; read address from table
  inc hl
  ld d,[hl]
  inc hl
  ex de,hl
  add hl,bc
  ld a,[hl]
  add a,iyl
  cp $50
  jq c,.not_looparound
  sub $50
.not_looparound:
  cp (pulsewave3.freq - 1) and $00ff
  jq nz,.not_pulsewave3freq
  inc a
.not_pulsewave3freq:
  ld [hl],a
  ex de,hl
  dec ixh
  jq nz,.relocate_w_loop

  dec ixl
  pop de
  jq nz,.loop


  ld hl,drumlcd
  ld bc,drumlcd.size
  ldir


  ld hl,$da00
  xor a
.zero_counters_loop:
  ld [hl],a
  inc l
  jq nz,.zero_counters_loop

  ld a,6
  ld [channels_playing],a
end macro

relocate_a.table:
relocatable relocate_a,relocate_a.len,relocate_a
relocate_w.table:
relocatable relocate_w,relocate_w.len,relocate_a

ch_driver:
db ch_driver.data
virtual at relocate_a

pulsewavex := relocate_w + waves_ram
pulsewavex.freq := pulsewavex + pulsewave.freq + 40
pulsewavex.width := pulsewavex + pulsewave.width
pulsewavex.mask := pulsewavex + pulsewave.mask

smcable channel_pointer,channel_pointer.addr
smcable note_len,note_len.addr
smcable rest_len,rest_len.addr

smcable note_len_type,note_len_type.addr
smcable note_len_argument,note_len_argument.addr
smcable mask,mask.addr
smcable global_mask,global_mask.addr

smcable pw_state,pw_state.addr
smcable pw_change,pw_change.addr
smcable pw_other_bound,pw_other_bound.addr
smcable pw_now_bound,pw_now_bound.addr
smcable pw_start,pw_start.addr
smcable pw_lower,pw_lower.addr
smcable pw_upper,pw_upper.addr

smcable arp_start,arp_start.addr
smcable arp_current,arp_current.addr
smcable arp_count,arp_count.addr
smcable arp_count_reset,arp_count_reset.addr
smcable arp_delay,arp_delay.addr
smcable arp_delay_reset,arp_delay_reset.addr

smcable vib_state,vib_state.addr
smcable vib_change,vib_change.addr
smcable vib_other_bound,vib_other_bound.addr
smcable vib_now_bound,vib_now_bound.addr
smcable vib_delay,vib_delay.addr
smcable vib_delay_reset,vib_delay_reset.addr
smcable vib_diff,vib_diff.addr
smcable vib_speed,vib_speed.addr

virtual
  adc hl,de
load _adc:1 from $-1
  sbc hl,de
load _sbc:1 from $-1
  jr c,$
load _jrc:1 from $-2
  jr nc,$
load _jrnc:1 from $-2
assert _adc xor _jrnc = _sbc xor _jrc
  ld hl,0
load _ldhl:1 from $-3
  jp 0
load _jp:1 from $-3
  jr $
load _jr:1 from $-2
  cp 0
load _cp:1 from $-2
end virtual

ch_driver.start:
general_driver:

  ld a,note_len + 1           ; if (!--note_len) {
  dec a
  jq nz,.play_note_normal
                              ;   note_len = 1;
  ld a,rest_len + 1           ;   if (!--rest_len) {
  dec a
  jq z,.rest_done

  ld [rest_len.addr],a
  xor a
  ld [pulsewavex.mask],a      ;   channel.mask = 0x00;
  jq ch_driver.next

.rest_done:
  ld hl,channel_pointer
.read_next_note:              ;     read_next_note:
  ld a,[hl]                   ;     if (*channel_pointer & 0x0f) {
  ld c,a
  and $0f
  jq z,.parse_command

  ld a,pw_start + $80         ;       if (pw_start)
  or a
  jq z,.no_set_pw_start
  ld [pulsewavex.width],a
  ex de,hl
  ld l,0                      ;         pw_state = pw_start << 8;
  ld h,a
  ld [pw_state.addr],hl

  ld a,[.pw_nc_smc]           ;       if (pw_decr) {
  cp _jrnc
  jq nz,.not_pw_decr

  ld a,pw_lower + $80
  ld [pw_other_bound.addr],a
  ld a,pw_upper + $80
  ld [pw_now_bound.addr],a

  ld a,_jrc                   ;         pw_decr = false;
  ld [.pw_nc_smc],a
  xor _jrc xor _jrnc
  ld [.pw_c_smc],a

  ld hl,[pw_change.addr]
  xor a
  sub l
  ld l,a
  sbc a,a
  sub h
  ld h,a
  ld [pw_change.addr],hl

.not_pw_decr:                 ;       }
  ex de,hl
.no_set_pw_start:

  ld a,[.do_arp_jr_smc]    ;       if (do_arp) {
  sub _cp
  jq nz,.not_arp_set

  ld d,a
  ld [arp_start.addr],hl      ;         arp_start = arp_current = channel_pointer;
  ld [arp_current.addr],hl
  ld a,1                      ;         arp_delay = 1;
  ld [arp_delay.addr],a ; make it read a new note immediately
  ld a,[arp_count_reset.addr] ;         arp_count = arp_count_reset;
  ld [arp_count.addr],a
  ld e,a                      ;         channel_pointer += arp_count_reset;
  add hl,de
  ld a,1

  jq .after_vib_set           ;       } else {
.not_arp_set:
  inc hl                      ;         vib_state = decode_note(*channel_pointer++);
  push hl
  call decode_note
  ld [pulsewavex.freq],hl
  ld [vib_state.addr],hl
  push hl
  ld a,vib_diff               ;         uint16_t vib_offset = vib_state * vib_diff >> 11;
  call calc_vib_diff
  ex de,hl
  pop hl                      ;         vib_other_bound = vib_state - vib_offset;
  push hl
  sbc hl,de
  ld [vib_other_bound.addr],hl
  add hl,de                   ;         vib_now_bound = vib_state + vib_offset;
  add hl,de
  ld [vib_now_bound.addr],hl
  pop hl                      ;         vib_change = vib_state * vib_speed >> 11;
  ld a,vib_speed
  call calc_vib_diff
  ld [vib_change.addr],hl
  ld a,vib_delay_reset        ;         vib_delay = vib_delay_reset;
  ld [vib_delay.addr],a
  ld a,_adc                   ;         vib_decr = false;
  ld [.vib_sbc_smc],a
  xor _adc xor _jrnc
  ld [.vib_c_smc],a
  pop hl
.after_vib_set:               ;       }

  ld c,[hl]                   ;       {note_len,rest_len} = do_note_len(*channel_pointer++);
  inc hl
  ld [channel_pointer.addr],hl
  call do_note_len

  ld a,mask + $03             ;       channel.mask = mask;
  and global_mask + $03
  ld [pulsewavex.mask],a

  jq .after_read_note         ;     } else {
.parse_command:
; value of HL will end up in DE
; C contains index<<4 into array of words at (switch_cases) (other bits are guaranteed zero)
; A contains zero
                              ;       switch (*channel_pointer++) {
  inc hl
  ex de,hl                    ; put channel_pointer into DE
  ld hl,.read_next_note       ; return address
  push hl
  ld b,a                      ; b = 0
  ld a,c                      ; c = c >> 3
  rrca                        ; (already guaranteed bottom 4 bits are 0)
  rrca                        ; (also, it's actually c >> 4 << 1 because word size)
  rrca
  ld c,a
  ld hl,.switch_cases         ; get the word from the table
  add hl,bc
  ld a,[hl]
  inc hl
  ld h,[hl]
  ld l,a
  xor a                       ; many of the routines expect a = 0
  jp hl                       ; go

.switch_cases:
  dw .cmd_pwm,.cmd_mask,.cmd_additive,.cmd_subtractive
  dw .cmd_fractional,.cmd_glide,.cmd_vibrato,.cmd_arpeggio
  dw .cmd_rest,cmd_jump,cmd_djnz,cmd_table_value
  dw cmd_set_phase,cmd_nothing,.cmd_finish,cmd_exit

.cmd_pwm:                     ;         case 0x00:
  ex de,hl
  ld a,[hl]                   ;           pw_start = *channel_pointer++;
  inc hl
  ld [pw_start.addr],a
  ld a,[hl]                   ;           pw_other_bound = *channel_pointer++;
  inc hl
  ld [pw_other_bound.addr],a
  ld [pw_lower.addr],a
  ld a,[hl]                   ;           pw_now_bound = *channel_pointer++;
  inc hl
  ld [pw_now_bound.addr],a
  ld [pw_upper.addr],a
  ld e,[hl]                   ;           pw_change = *channel_pointer++;
  inc hl
  ld d,[hl]                   ;           pw_change |= *channel_pointer++ << 8;
  inc hl
  ld [pw_change.addr],de
  ld a,_jrc                   ;           pw_decr = false;
  ld [.pw_nc_smc],a
  xor _jrc xor _jrnc
  ld [.pw_c_smc],a
  ret                         ;           break;

.cmd_mask:                    ;         case 0x10:
  ex de,hl
  ld a,[hl]                   ;           mask = *channel_pointer++;
  inc hl
  ld [mask.addr],a
  ret                         ;           break;

.cmd_fractional:              ;         case 0x40:
  inc a                       ;           note_len_type = FRACTIONAL;
.cmd_subtractive:             ;         case 0x30:
  inc a                       ;           note_len_type = SUBTRACTIVE;
.cmd_additive:                ;         case 0x20:
  ld [note_len_type.addr],a   ;           note_len_type = ADDITIVE;
  ex de,hl
  ld a,[hl]                   ;           note_len_argument = *channel_pointer++;
  inc hl
  ld [note_len_argument.addr],a
  ret                         ;           break;

; the following section has had many of its C lines rearranged to be able to use more registers
.cmd_glide:                   ;         case 0x50:
  ld a,[de]                   ;           vib_other_bound = decode_note(*channel_pointer++);
  inc de
  ld c,a
  call decode_note
  ld [vib_other_bound.addr],hl
  ld [vib_state.addr],hl      ;           vib_state = vib_other_bound;
  ld a,_jr                    ;           do_arp = false;
  ld [.do_arp_jr_smc],a
  ld a,[de]                   ;           vib_now_bound = decode_note(*channel_pointer++);
  inc de
; push de ; channel_pointer
  push hl ; first note
  ld c,a
  call decode_note
  ld [vib_now_bound.addr],hl
  pop bc                      ;           vib_change = abs(vib_other_bound - vib_now_bound) / note_len;
  or a
  sbc hl,bc ; second - first
  ld a,_sbc
  jq nc,.glide_down
  ld a,l
  neg
  ld l,a
  ld a,h
  sbc a,0
  cpl
  ld h,a

  ld a,_adc                   ;           vib_decr = vib_now_bound < vib_other_bound;
.glide_down:
  ld [.vib_sbc_smc],a
  xor _adc xor _jrnc
  ld [.vib_c_smc],a

; pop de
  ld a,[de]
  inc de
  ld c,a
  call do_note_len            ;           {note_len,rest_len} = do_note_len(*channel_pointer++);
  ld b,a                      ;           vib_change = abs(vib_other_bound - vib_now_bound) / note_len;
  call hl_div_b
  ld [vib_change.addr],hl
  ex de,hl
  ret                         ;           break;

.cmd_vibrato:                 ;         case 0x60:
  ex de,hl
  ld a,_jr                    ;           do_arp = false;
  ld [.do_arp_jr_smc],a
  ld a,[hl]                   ;           vib_delay_reset = *channel_pointer++ + 1;
  inc hl
  inc a
  ld [vib_delay_reset.addr],a
  ld a,[hl]                   ;           vib_diff = *channel_pointer++;
  inc hl
  ld [vib_diff.addr],a
  ld a,[hl]                   ;           vib_speed = *channel_pointer++;
  inc hl
  ld [vib_speed.addr],a
  ret                         ;           break;

.cmd_arpeggio:                ;         case 0x70:
  ex de,hl
  ld a,_cp                    ;           do_arp = true;
  ld [.do_arp_jr_smc],a
  ld a,[hl]                   ;           arp_count_reset = *channel_pointer++;
  inc hl
  ld [arp_count_reset.addr],a
  ld a,[hl]                   ;           arp_delay_reset = *channel_pointer++;
  inc hl
  ld [arp_delay_reset.addr],a
  ret                         ;           break;

.cmd_rest:                    ;         case 0x80:
  ld [pulsewavex.mask],a      ;           channel.mask = 0;
  ex de,hl
  ld a,[hl]                   ;           rest_len = *channel_pointer++ + 1;
  inc hl
; inc a
  ld [rest_len.addr],a
  ld [channel_pointer.addr],hl
  pop af
  jq ch_driver.next           ;           break;

.cmd_finish:                  ;         case 0xe0:
  ld [pulsewavex.mask],a      ;           channel.mask = 0;
  pop hl
  ld hl,channels_playing      ;           playing--;
  dec [hl]
  ret z
  ld a,_jp
  ld [general_driver],a
  ld hl,ch_driver.next
  ld [general_driver + 1],hl
  jp hl                       ;           return;

.play_note_normal:
  ld [note_len.addr],a

.after_read_note:             ; }

  ld hl,pw_state              ; if (pw_decr)
  ld bc,pw_change             ;   pw_state -= pw_change;
                              ; else
  add hl,bc                   ;   pw_state += pw_change;
  ld a,pw_now_bound + $80
.pw_nc_smc:
  jr c,.pw_wraparound         ; if (carry || pw_decr ? pw_state < pw_now_bound : pw_state > pw_now_bound) {
  cp h
.pw_c_smc:
  jr nc,.pw_no_wraparound
.pw_wraparound:
  ld d,a

; the following lines are swapped around a bit for speed (and also for confusion)
                              ;   pw_state = 2 * pw_now_bound - pw_state;
                              ;   swap(pw_now_bound,pw_other_bound);
; first part of the swap
  ld a,pw_other_bound + $80
  ld [pw_now_bound.addr],a
; first part of the wraparound
  xor a
  sub l
  ld e,a
; second part of the swap
  ld a,d
  ld [pw_other_bound.addr],a
; second part of the wraparound
  ccf
  adc a,a
  sub h
  ld d,a

  xor a
  sub c
  ld l,a
  sbc a,b
  sub l
  ld h,a
  ld [pw_change.addr],hl
  ex de,hl

  ld a,[.pw_nc_smc]           ;   pw_decr = !pw_decr;
  ld [.pw_c_smc],a
  xor _jrc xor _jrnc
  ld [.pw_nc_smc],a
.pw_no_wraparound:            ; }
  ld [pw_state.addr],hl
  ld a,h                      ; channel.pw = pw_state >> 8;
  ld [pulsewavex.width],a

; smc between JR and CP to choose arp or vib
.do_arp_jr_smc:
  cp .do_vib - ($ + 2)        ; if (do_arp) {
  ld a,arp_delay              ;   if (!--arp_delay) {
  dec a
  jq nz,.arp_delayed

  ld hl,arp_current           ;     channel.freq = decode_note(arp_current++);
  ld c,[hl]
  inc hl

  ld a,arp_count + 1          ;     if (!--arp_count) {
  dec a
  jq nz,.no_arp_repeat
  ld hl,arp_start             ;       arp_current = arp_start;
  ld a,arp_count_reset + 1    ;       arp_count = arp_count_reset;
.no_arp_repeat:               ;     }
  ld [arp_count.addr],a

  ld [arp_current.addr],hl    ;     channel.freq = decode_note(arp_current++);
  call decode_note
  ld [pulsewavex.freq],hl

  ld a,arp_delay_reset + 1    ;     arp_delay = arp_delay_reset;
.arp_delayed:                 ;   }
  ld [arp_delay.addr],a
  jq ch_driver.next           ; } else {

; will only ever reach this if the JR C is SMC'd to a JR NC, so carry is always reset
.do_vib:
  ld a,vib_delay + 1          ;   if (!--vib_delay) {
  dec a
  jr nz,.vib_delayed          ; TODO jq

  ld hl,vib_state             ;     channel.freq = vib_state;
  ld [pulsewavex.freq],hl
  ld de,vib_change            ;     if (vib_decr)
.vib_sbc_smc := $ + 1         ;       vib_state -= vib_change;
  adc hl,de                   ;     else
                              ;       vib_state += vib_change;
; assume carry never happens here either because sensible frequency ranges

  ex de,hl                    ;     if (vib_decr ? vib_state < vib_now_bound : vib_state > vib_now_bound) {
  ld hl,vib_now_bound
  sbc hl,de
.vib_c_smc:
  jq nc,.vib_no_wraparound

  ld de,[vib_now_bound.addr]  ;       vib_state = 2 * vib_now_bound - vib_state;
  add hl,de
  ex de,hl
  ld bc,vib_other_bound       ;       swap(vib_now_bound,vib_other_bound);
  ld [vib_other_bound.addr],hl
  ld [vib_now_bound.addr],bc

  ld a,[.vib_sbc_smc]
  xor _adc xor _sbc
  ld [.vib_sbc_smc],a
  xor _adc xor _jrnc
  ld [.vib_c_smc],a

.vib_no_wraparound:
  ld [vib_state.addr],de

  jq ch_driver.next

; do_note_len: adjust a note length using any of ADDITIVE, SUBTRACTIVE, and FRACTIONAL
; inputs:
;   C: original note length
;   [note_len_type.addr]: the type of length adjustment
;   [note_len_argument.addr]: the argument used for the time adjustment
; outputs:
;   [note_len]: adjusted note length
;   [rest_len]: consequent rest length
;   A: [note_len]
; destroys:
;   AF, BC, HL
do_note_len:
  ld a,note_len_argument + 0
  ld b,note_len_type + 1
  djnz .not_subtractive
.subtractive:
  cp c
  jq c,.subtract_len
.full_len:
  ld a,1
  ld [rest_len.addr],a
  ld a,c
  ld [note_len.addr],a
  ret

.subtract_len:
  ld b,a
  inc a
  ld [rest_len.addr],a
  ld a,c
  sub b
  ld [note_len.addr],a
  ret

.not_subtractive:
  djnz .not_fractional
.fractional:
  push de
  ld e,c
  ld h,a
  call e_mul_h
  ld a,c
  sub h
  inc a
  ld [rest_len.addr],a
  ld a,h
  ld [note_len.addr],a
  pop de
  ret

.not_fractional:
.additive:
  cp c
  jq nc,.full_len
  ld b,a
  ld [note_len.addr],a
  ld a,c
  sub b
  inc a
  ld [rest_len.addr],a
  ld a,b
  ret

general_driver.vib_delayed:
  ld [vib_delay.addr],a

ch_driver.next:
ch_driver.size := $ - $$
load ch_driver.data: ch_driver.size from $$
end virtual

repeat 1,x:ch_driver.size
  display "driver size per channel: ",`x,10
end repeat

drumbass:
db drumbass.data
virtual at driver_ram + 2 * ch_driver.size

call_drum_1:
  call drum

smcable bass_len,bass_len.addr
smcable bass_rest_len,bass_rest_len.addr
smcable bass_mask,bass_mask.addr
smcable bass_globalmask,bass_globalmask.addr
smcable bass_outmask,bass_outmask.addr
smcable bass_outlen,bass_outlen.addr
smcable bass_arp_delay,bass_arp_delay.addr
smcable bass_arp_delay_reset,bass_arp_delay_reset.addr
smcable bass_pointer,bass_pointer.addr
smcable bass_arp_current,bass_arp_current.addr
smcable bass_arp_start,bass_arp_start.addr
smcable bass_arp_count,bass_arp_count.addr
smcable bass_arp_count_reset,bass_arp_count_reset.addr
smcable bass_note_len_arg,bass_note_len_arg.addr
smcable bass_note_len_type,bass_note_len_type.addr

bass:

  ld a,bass_len + 1           ; if (!--bass_len)
  dec a
  jq nz,.playing
                              ;   bass_len = 1;
  ld a,bass_rest_len + 1      ;   if (!--bass_rest_len) {
  dec a
  jq z,.read_next_note
  ld [bass_outmask.addr],a    ;   (else) bass.out.mask = 0x00;
  jq .resting

.read_next_note:
  ld hl,bass_pointer          ;     if (*bass_pointer & 0x0f) {
  ld a,[hl]
  ld c,a
  and $0f
  jq z,.parse_command

  ld [bass_arp_start.addr],hl ;       bass_arp_start = bass_arp_current = bass_pointer;
  ld [bass_arp_current.addr],hl
  ld a,[bass_arp_delay_reset.addr] ;  bass_arp_delay = bass_arp_delay_reset;
  ld [bass_arp_delay.addr],a
  ld a,[bass_arp_count_reset.addr] ;  bass_arp_count = bass_arp_count_reset;
  ld [bass_arp_count.addr],a
  ld a,bass_mask              ;       bass.out.mask = bass_mask & bass_globalmask;
  and bass_globalmask + $03
  ld [bass_outmask.addr],a
  add a,l                     ;       bass_pointer += bass_arp_count_reset;
  ld l,a
  adc a,h
  sub l
  ld h,a
  ld c,[hl]                   ;       {bass_len,bass_rest_len} = do_note_len(*bass_pointer++);
  inc hl
  ld [bass_pointer.addr],hl

.do_note_len:
  ld a,bass_note_len_arg + 0
  ld b,bass_note_len_type + 1
  djnz .not_subtractive
.subtractive:
  cp c
  jq c,.subtract_len
.full_len:
  ld a,1
  ld [bass_rest_len.addr],a
  ld a,c
  ld [bass_len.addr],a
  jq .done_read

.subtract_len:
  ld b,a
  inc a
  ld [bass_rest_len.addr],a
  ld a,c
  sub b
  ld [bass_len.addr],a
  jq .done_read

.not_subtractive:
  djnz .not_fractional
.fractional:
  push de
  ld e,c
  ld h,a
  call e_mul_h
  ld a,c
  sub h
  inc a
  ld [bass_rest_len.addr],a
  ld a,h
  ld [bass_len.addr],a
  pop de
  jq .done_read

.not_fractional:
.additive:
  cp c
  jq nc,.full_len
  ld b,a
  ld [bass_len.addr],a
  ld a,c
  sub b
  inc a
  ld [bass_rest_len.addr],a
  ld a,b

                              ;     } else {
                              ;       (later)
.done_read:                   ;     }
                              ;   }
.playing:                     ; }
  ld a,bass_arp_delay + 1     ; if (!--bass_arp_delay) {
  dec a
  jq nz,.bass_arp_delayed

  ld a,bass_arp_count + 1     ;   if (!--bass_arp_count) {
  dec a
  jq nz,.bass_arp_next

  ld hl,bass_arp_start        ;     bass_arp_current = bass_arp_start;
  ld [bass_arp_current.addr],hl

  ld a,bass_arp_count_reset + 1 ;   bass_arp_count = bass_arp_count_reset;
.bass_arp_next:               ;   }
  ld [bass_arp_count.addr],a

  ld a,bass_arp_delay_reset + 1 ; bass_arp_delay = bass_arp_delay_reset;
.bass_arp_delayed:            ; }
  ld [bass_arp_delay.addr],a


  ld hl,bass_arp_current      ; bass_arp_current++;
  ld b,[hl]
  inc hl
  ld [bass_arp_current.addr],hl

  decode_note_bass            ;   bass.wavelength = bass_decode_note(bass_arp_current);
  ld [bass_outlen.addr],a

.resting:
  scf                         ; if (!mute_bass) {
.smc_mute_c:
  jq nc,.mute_bass

  ld a,bass_outlen            ;   bass.wavelength = bass.out.length;
  ld [basswave.length],a
  ld a,bass_outmask           ;   bass.mask = bass.out.mask;
  ld [basswave.mask],a
  jq .finish_bass


.parse_command:
; same code as general_driver.parse_command above
  inc hl                      ;       switch (*bass_pointer++) {
  ex de,hl
  ld hl,.read_next_note
  push hl
  ld b,a
  ld a,c
  rrca
  rrca
  rrca
  ld c,a
  ld hl,.switch_cases
  add hl,bc
  ld a,[hl]
  inc hl
  ld h,[hl]
  ld l,a
  xor a
  jp hl

.switch_cases:
  dw cmd_nothing,.cmd_mask,.cmd_additive,.cmd_subtractive
  dw .cmd_fractional,cmd_nothing,cmd_nothing,.cmd_arpeggio
  dw .cmd_rest,cmd_jump,cmd_djnz,cmd_table_value
  dw cmd_set_phase,cmd_nothing,.cmd_finish,cmd_exit

.cmd_mask:                    ;         case 0x10:
  ex de,hl
  ld a,[hl]                   ;           mask = *bass_pointer++;
  inc hl
  ld [bass_mask.addr],a
  ret                         ;           break;

.cmd_fractional:              ;         case 0x40:
  inc a                       ;           note_len_type = FRACTIONAL;
.cmd_subtractive:             ;         case 0x30:
  inc a                       ;           note_len_type = SUBTRACTIVE;
.cmd_additive:                ;         case 0x20:
  ld [bass_note_len_type.addr],a ;        note_len_type = ADDITIVE;
  ex de,hl
  ld a,[hl]                   ;           note_len_argument = *bass_pointer++;
  inc hl
  ld [bass_note_len_arg.addr],a
  ret                         ;           break;

.cmd_arpeggio:                ;         case 0x70:
  ex de,hl
  ld a,[hl]                   ;           bass_arp_count_reset = *bass_pointer++;
  inc hl
  ld [bass_arp_count_reset.addr],a
  ld a,[hl]                   ;           bass_arp_delay_reset = *bass_pointer++;
  inc hl
  ld [bass_arp_delay_reset.addr],a
  ret                         ;           break;

.cmd_rest:                    ;         case 0x80:
  ld [bass_outmask.addr],a    ;           bass.out.mask = 0;
  ex de,hl
  ld a,[hl]                   ;           bass_rest_len = *bass_pointer++ + 1;
  inc hl
  inc a
  ld [bass_rest_len.addr],a
  ret                         ;           break;

.cmd_finish:                  ;         case 0xe0:
  pop hl
  ld hl,channels_playing      ;           playing--;
  dec [hl]
  ret z

  ld [bass_outmask.addr],a    ;           bass.out.mask = 0;

  ld a,_jp
  ld [bass],a
  ld hl,.finish_bass
  ld [bass + 1],hl
; jp hl                       ;           return;


.mute_bass:
.finish_bass:
  call wait_frame

  drumbass.size := $ - $$
  load drumbass.data: drumbass.size from $$
end virtual

drumlcd:
db drumlcd.data
virtual at driver_ram + 4 * ch_driver.size + drumbass.size

call_drum_2:
  call drum

lcd:
; TODO

  call wait_frame
  jq driver_ram



wait_frame:
  in a,[$04]
  and $40
  jr z,wait_frame
  ld a,$01
  out [$34],a
  in a,[$04]
  and $08
  ret nz
  pop af
  ret

smcable drum_rest_len,drum_rest_len.addr
smcable drum_mask,drum_mask.addr
smcable drum_globalmask,drum_globalmask.addr
smcable drum_pointer,drum_pointer.addr
smcable drum_len,drum_len.addr
smcable drum_sequence_pointer,drum_sequence_pointer.addr

drum:
  ld a,drum_rest_len + 1      ; if (!--drum_rest_len) {
  dec a
  jq nz,.not_read_next

  ld hl,drum_pointer
.read_next_note:              ;   drum_next_note:
  ld a,[hl]                   ;   drum_rest_len = *drum_pointer++;
  inc hl
  or a                        ;   if (!drum_rest_len) {
  jq z,.parse_command
                              ;     ... (see below)
                              ;   }
  ld [drum_rest_len.addr],a

  ld e,[hl]                   ;   uint16_t read = *drum_pointer++;
  inc hl
  ld d,[hl]                   ;   read |= *drum_pointer++ << 8;
  inc hl
  ld [drum_pointer.addr],hl
  ld hl,[appvar_start]        ;   read += appvar_start;
  add hl,de                   ;   drum_sequence_pointer = (uint8_t *) read;
  ld a,[hl]                   ;   drum_len = *drum_sequence_pointer++;
  inc hl
  jq .new_note
; inc a
; ld [drum_len.addr],a
; ld [drum_sequence_pointer.addr],hl

.not_read_next:               ; }
  ld [drum_rest_len.addr],a
  ld a,drum_len               ; if (--drum_len) {
  dec a
  jr z,.no_drum
  ld hl,drum_sequence_pointer
.new_note:
  ld [drum_len.addr],a

  ld a,[hl]                   ;   uint8_t read = *drum_sequence_pointer++;
  inc hl
  ld [drum_sequence_pointer.addr],hl
  or a                        ;   if (read) {
  jq z,.play_noise

  ld [basswave.length],a      ;     bass.wavelength = read;
  ld a,basswave and $00ff     ;     noise.playing = false;
  ld [pulsewave3.next],a

  jq .mute_bass               ;   } else {

.play_noise:
  ld a,noisewave and $00ff    ;     noise.playing = true;
  ld [pulsewave3.next],a
.mute_bass:                   ;   }

  ld a,_jrc                   ;   mute_bass = true;
  ld [bass.smc_mute_c],a
  ld a,drum_mask + $03
  and drum_globalmask + $03
  ld [noisewave.mask],a
  ld [basswave.mask],a
  ret


.no_drum:                     ; } else {
                              ;   drum_len = 1;
; disable drum driver, give back control over the drumbass channel to bass driver
; ld [noisewave.mask],a       ;   noise.mask = 0;
; ^ not actually necessary because the bass channel will take over anyway
  ld a,[bass_outlen.addr]     ;   bass.wavelength = bass.out.length;
  ld [basswave.length],a
  ld a,[bass_outmask.addr]    ;   bass.mask = bass.out.mask;
  ld [basswave.mask],a
  ld a,basswave and $00ff
  ld [pulsewave3.next],a
  ld a,_jrnc                  ;   mute_bass = false;
  ld [bass.smc_mute_c],a
  ret                         ; }

.parse_command:               ; the ... above goes here
  ld a,[hl]                   ;     switch (*drum_pointer++) {
  inc hl
  and $f0
  ex de,hl
  ld hl,.read_next_note
  push hl
  rrca
  rrca
  rrca
  ld hl,.switch_cases
  add a,l
  ld l,a
  adc a,h
  sub l
  ld h,a

  ld a,[hl]
  inc hl
  ld h,[hl]
  ld l,a
  xor a
  jp hl

.switch_cases:
  dw cmd_nothing,.cmd_mask,cmd_nothing,cmd_nothing
  dw cmd_nothing,cmd_nothing,cmd_nothing,cmd_nothing
  dw .cmd_rest,cmd_jump,cmd_djnz,cmd_table_value
  dw cmd_set_phase,cmd_nothing,.cmd_finish,cmd_exit_extra_pop

.cmd_mask:                    ;         case 0x10:
  ex de,hl
  ld a,[hl]                   ;           mask = *drum_pointer++;
  inc hl
  ld [drum_mask.addr],a
  ret                         ;           break;

.cmd_rest:                    ;         case 0x80:
  ex de,hl
  ld a,[hl]                   ;           drum_rest_len = *drum_pointer++ + 1;
  inc hl
  inc a
  ld [drum_rest_len.addr],a
  ret                         ;           break;

.cmd_finish:                  ;         case 0xe0:
  pop hl
  ld hl,channels_playing      ;           playing--;
  dec [hl]
  jq nz,.finish_no_exit
  pop hl
  ret
.finish_no_exit:

  ld a,[bass_outlen.addr]     ;   bass.wavelength = bass.out.length;
  ld [basswave.length],a
  ld a,[bass_outmask.addr]    ;   bass.mask = bass.out.mask;
  ld [basswave.mask],a
  ld a,basswave and $00ff
  ld [pulsewave3.next],a
  ld a,_jrnc                  ;   mute_bass = false;
  ld [bass.smc_mute_c],a

  ld a,_ldhl
  ld [call_drum_1],a
  ld [call_drum_2],a
  ret

drumlcd.size := $ - $$
load drumlcd.data: drumlcd.size from $$
end virtual


cmd_jump:                     ;         case 0x90:
  ex de,hl
  ld e,[hl]                   ;           uint16_t ofs = *channel_pointer++;
  inc hl
  ld d,[hl]                   ;           ofs |= *channel_pointer << 8;
  ld hl,[appvar_start]        ;           channel_pointer = appvar_start + ofs;
  add hl,de
  ret                         ;           break;

cmd_djnz:                     ;         case 0xa0:
  ld a,[de]                   ;           if (--jump_counters[*bass_pointer++]) {
  inc de
  ld l,a
  ld h,djnz_counters_ram shr 8
  dec [hl]
  ex de,hl
  jq z,.djnz_z
  ld e,[hl]                   ;             uint16_t ofs = *channel_pointer++;
  inc hl
  ld d,[hl]                   ;             ofs |= *channel_pointer << 8;
  ld hl,[appvar_start]        ;             channel_pointer = appvar_start + ofs;
  add hl,de
  ret                         ;           break;

.djnz_z:                      ;           } else
  inc hl                      ;             channel_pointer += 2;
  inc hl
  ret                         ;           break;

cmd_table_value:              ;         case 0xb0:
  ex de,hl
  ld e,[hl]                   ;           uint8_t i = *channel_pointer++;
  inc hl
  ld d,djnz_counters_ram shr 8;           jump_counters[i] = *channel_pointer++;
  ldi
  ret

cmd_set_phase:                ;         case 0xc0:
  ld a,[de]                   ;           uint8_t bits = *channel_pointer++;
  inc de
  rrca                        ;           if (bits & 0x01)
  di
  exx
  jq nc,.not_wave0
  ld ix,0                     ;             channel0.phase = 0;
.not_wave0:
  rrca                        ;           if (bits & 0x02)
  jq nc,.not_wave1
  ld iy,0                     ;             channel1.phase = 0;
.not_wave1:
  rrca                        ;           if (bits & 0x04)
  jq nc,.not_wave2
  ld bc,0                     ;             channel2.phase = 0;
.not_wave2:
  rrca                        ;           if (bits & 0x08)
  jq nc,.not_wave3
  ld de,0                     ;             channel3.phase = 0;
.not_wave3:
  rrca                        ;           if (bits & 0x10)
  exx ; HL cannot be destroyed, use other HL
  jq nc,.not_bass
  ld hl,$0000                 ;             bass.state = 0;
  ld [basswave.state],hl
.not_bass:
  rrca                        ;           if (bits & 0x20)
  jq nc,.not_noise
  ld hl,$0001                 ;             noise.seed = 1;
  ld [noisewave.seed],hl
.not_noise:
  ei
  ex de,hl
cmd_nothing:                  ;         default:
  ret                         ;           break;

cmd_exit_extra_pop:
  pop hl
cmd_exit:                     ;         case 0xf0:
  pop hl
  ret

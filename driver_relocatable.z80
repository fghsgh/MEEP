; this source file handles reading note data and SMCing certain bytes in bitbang.z80 to change what notes are playing
; the general-purpose driver, ch_driver, is relocatable
;  it gets copied to RAM on start four times, the drumbass driver is appended once, this drumbass driver will also wait for the next frame and jump back to the first general-purpose driver
;   relocate_a are addresses within the driver itself (org $0000 is assumed)
;   relocate_w are addresses inside the pulsewave bitbang routines (thus depending on the channel)
;   relocate_d is the LSB of the data of a single channel, it can be $00 (ch 0), $40 (ch 1), $80 (ch 2), $c0 (ch 3)
; the drumbass driver, db_driver, is not relocatable, its origin is assumed to be $c6ec + 4 * driver.size


macro driver_init
driver_init_c:
  ld c,4
  ld de,$c6ec

.loop:
  ld a,c
  push de

  ld hl,ch_driver
  ld bc,ch_driver.size
  ldir

  ex de,hl
  ex (sp),hl
  ex de,hl
  ld b,relocate_a.len
  ld c,a
  ld ix,relocate_a.table
.relocate_a_loop:
  ld l,(ix)
  inc ix
  ld h,(ix)
  inc ix
  add hl,de
  push hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  add hl,de
  ex (sp),hl
  dec sp
  pop af
  ld (hl),a
  inc hl
  dec sp
  pop af
  ld (hl),a
  djnz .relocate_a_loop

  ld b,relocate_d.len
  ld a,4
  sub c
  rrca
  rrca
  ld ix,relocate_d.table
.relocate_d_loop:
  ld l,(ix)
  inc ix
  ld h,(ix)
  inc ix
  add hl,de
  ld (hl),a
  djnz .relocate_d_loop

  rlca
  rlca
  add a,a
  add a,a
  ld e,a
  add a,a
  add a,a
  add a,e
  ld e,a

  ld b,relocate_w.len
  ld ix,relocate_w.table
.relocate_w_loop:
  ld l,(ix)
  inc ix
  ld h,(ix)
  inc ix
  ld a,(hl)
  add a,e
  cp $50
  jr c,.not_looparound
  sub $50
.not_looparound:
  ld (hl),a
  djnz .relocate_w_loop

  dec c
  pop de
  jr nz,.loop


  ld hl,drumbass
  ld de,$c6ec + 4 * ch_driver.size
  ld bc,drumbass.size
  ldir


  ld hl,$da00
  xor a
.zero_counters_loop:
  ld (hl),a
  inc l
  jr nz,.zero_counters_loop


  ld a,$40                    ; 50 Hz -> timer 3
  out ($36),a
  ld a,$01
  out ($37),a
  ld a,218
  out ($38),a
end macro

; fasmg is wonderful
relocate_a.table:
relocatable relocate_a,relocate_a.len,relocate_a
relocate_w.table:
relocatable relocate_w,relocate_w.len,relocate_a
relocate_d.table:
relocatable relocate_d,relocate_d.len,relocate_a

ch_driver:
db ch_driver.data
virtual at relocate_a

smcable pw_state,pw_state_addr
smcable pw_change,pw_change_addr
smcable pw_max2,pw_max2_addr
smcable pw_max,pw_max_addr
smcable pw_min,pw_min_addr
smcable pw_min2,pw_min2_addr

smcable vib_reljump,vib_reljump_addr
smcable arp_count,arp_count_addr
smcable arp_index,arp_index_addr

smcable vib_state,vib_state_addr
smcable vib_delay,vib_delay_addr
smcable vib_change,vib_change_addr
smcable vib_max,vib_max_addr
smcable vib_offset,vib_offset_addr

smcable note_length,note_length_addr
smcable mask,mask_addr
smcable rest_length,rest_length_addr

smcable channel_pointer,channel_pointer_addr
smcable pw_start,pw_start_addr
smcable arp_count2,arp_count2_addr
smcable vib_delay_reset,vib_delay_reset_addr
smcable vib_difference,vib_difference_addr
smcable vib_speed,vib_speed_addr

smcable notelength_reljump,notelength_reljump_addr
smcable notelength_argument,notelength_argument_addr

pulsewavex := relocate_w
pulsewavex.freq := pulsewavex + pulsewave.freq
pulsewavex.width := pulsewavex + pulsewave.width
pulsewavex.mask := pulsewavex + pulsewave.mask

; ramp pulse width
  ld hl,pw_state + $0000
  ld de,pw_change + $0000
  or a
.pw_direction := $ + 1
  adc hl,de
  jr nc,.pw_no_carry

  ld a,(.pw_direction)
  cp $5a
  jr z,.pw_set_sbc

.pw_set_adc:
  xor a
  sub l
  ld l,a

  ld a,pw_max2 + $fe          ; double of (.pw_max)
  sub h
  ld h,a

  ld a,$5a
  ld (.pw_direction),a
  jr .after_pw

.pw_no_carry:
  ld a,h
  cp pw_max
  jr c,.pw_set_adc

  cp pw_min
  jr nc,.after_pw

.pw_set_sbc:
  xor a
  sub l
  ld l,a

  ld a,pw_min2
  sub h
  ld h,a

  ld a,$52
  ld (.pw_direction),a

.after_pw:
  ld (pw_state_addr),hl
  ld a,h
  ld (pulsewavex.width),a


; arpeggio / vibrato
  jr vib_reljump + $ + 2      ; will be SMC'd to jump to .vib to do vibrato
vib_reljump_org:

; arpeggio
  ld hl,$d900 + relocate_d + arp_index
  ld b,(hl)
  ex de,hl
  call decode_note
  ld (pulsewavex.freq),hl
  ld a,e
  and $3f
  inc a
  cp arp_count
  jr c,.arp_not_last
  xor a
.arp_not_last:
  ld l,a
  ld a,e
  and $c0
  or l
  ld (arp_index_addr),a
  jr .after_arp_vib


; vibrato
.vib:
  ld hl,vib_state
  ld a,vib_delay
  dec a
  jr z,.start_vib
  ld (vib_delay_addr),a
  jr .vib_end

.start_vib:
  ld de,vib_change
  or a
.vib_direction := $ + 1
  adc hl,de

  jr nc,.vib_no_overflow      ; assume this will never overflow while adding (because of frequency ranges blah blah blah), so this happened while subtracting
  ld a,l                      ; invert HL
  cpl
  ld l,a
  ld a,h
  cpl
  ld h,a
  inc hl
  ld a,$5a                    ; set back to ADC
  ld (.vib_direction),a
  ld (vib_state_addr),hl
  jr .vib_end

.vib_no_overflow:
  ld de,vib_max + $0001
  or a
  sbc hl,de
  jr c,.vib_end_read

  ex de,hl
  sbc hl,de
  ld (vib_state_addr),hl
  jr .vib_end

.vib_end_read:
  ld hl,(vib_state_addr)
.vib_end:
  ld de,vib_offset
  add hl,de
  ld (pulsewavex.freq),hl

.after_arp_vib:


; note length
.play_decrement:
  ld a,note_length + $01
  dec a
  jr z,.silent_decrement
  ld (note_length_addr),a
  ld a,note_mask
  ld (pulsewavex.mask),a
  jp .next

.silent_decrement:
  ld (pulsewavex.mask),a
  ld a,rest_length + $01
  dec a
  jr z,.read_note
  ld (rest_length_addr),a
  jp .next


; read next note
.read_note:
  ld hl,channel_pointer
.next_command:
  ld a,(hl)
  inc hl
  ld b,a
  and $0f
  jr z,.parse_command

; reset arpeggio
  xor a
  ld (arp_index_addr),a

; do pulse width
  ld e,a
  ld a,pw_start
  or a
  jr z,.skip_pwset
  ld d,a
  ld (pw_state_addr),de
.skip_pwset:

; read all notes of arpeggio (vibrato will read the first of these later)
  ld a,arp_count2 + $01
  or a
  jr nz,.arp_not_zero
  ld a,$40
.arp_not_zero:
  ld c,a
  ld b,$00
  ld de,$d900 + relocate_d
  dec hl
  ldir

; read note length
  ld a,(hl)
  inc hl
  ld (channel_pointer_addr),hl

; process note length
  ld e,notelength_argument
  jr notelength_reljump + $ + 2
.notelength_reljump_org:
  sub e
  jr nc,.add_length_no_overflow

  add a,e
  ld e,a
  xor a

.add_length_no_overflow:
  inc a
  ld (rest_length_addr),a
  ld a,e
  ld (note_length_addr),a
  jr .after_length

.jr_sub:
  sub e
  jr nc,.sub_length_no_overflow

  add a,e
  ld e,a
  ld a,1

.sub_length_no_overflow:
  ld (note_length_addr),a
  ld a,e
  inc a
  ld (rest_length_addr),a
  jr .after_length

.jr_frac:
  ld h,a
  ld c,a
  call e_mul_h
  ld a,c
  sub h
  inc a
  ld (rest_length_addr),a
  ld a,h
  or a
  jr z,.read_note
  ld (note_length_addr),a

.after_length:

  ld a,vib_delay_reset + $01
  ld (vib_delay_addr),a

  
  ld (vib_offset_addr),hl
  add hl,hl
  push hl
  ld e,vib_difference
  call e_mul_h
  ld e,l
  ld d,h
  ld (vib_state_addr),hl
  add hl,hl
  ld (vib_max_addr),hl
  pop hl
  ld e,vib_speed
  call e_mul_h
  ld (vib_change_addr),hl

  
  ; TODO handle vibrato offset values
  ; update: maybe it's done, check while debugging

  jp .next

.parse_command:
  ld a,b
  rrca
  rrca
  rrca
  rrca
  and $0f
  jr nz,.not_pwset

  ld a,(hl)
  inc hl
  ld (pw_start_addr),a

  ld a,(hl)
  inc hl
  ld (pw_min_addr),a
  add a,a
  ld (pw_min2_addr),a

  ld a,(hl)
  inc hl
  ld (pw_max_addr),a
  add a,a
  ld (pw_max2_addr),a

  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (pw_change_addr),de
  jp .next_command

.not_pwset:
  ld b,a
  djnz .not_maskset

  ld a,(hl)
  inc hl
  and full_mask
  ld (mask_addr),a
  jp .next_command

.not_maskset:
  djnz .not_notelength_additive

  xor a
  jr .set_notelength

.not_notelength_additive:
  djnz .not_notelength_subtractive

  ld a,.jr_sub - .notelength_reljump_org
  jr .set_notelength

.not_notelength_subtractive:
  djnz .not_notelength_fractional

  ld a,.jr_frac - .notelength_reljump_org
.set_notelength:
  ld (notelength_reljump_addr),a
  ld a,(hl)
  inc hl
  ld (notelength_argument_addr),a
  jp .next_command

.not_notelength_fractional:
  djnz .not_glide

  ld a,.vib - .vib_reljump_org
  ld (vib_reljump_addr),a
  ld a,$01
  ld (arp_count_addr),a
  ld (arp_count2_addr),a
  ld (vib_delay_addr),a

  ld d,(hl)
  inc hl
  ld e,(hl)
  inc hl
  ld c,(hl)
  inc hl
  ld (channel_pointer_addr),hl
  ld b,d
  call decode_note
  ld ($d900 + relocate_d),hl
  ld b,e
  ex de,hl
  call decode_note
  or a
  sbc hl,de
  jr nc,.glide_up

  add hl,de
  ld (vib_offset_addr),hl
  ex de,hl
  or a
  sbc hl,de
  ld (vib_max_addr),hl
  call hl_div_c
  ld (vib_change_addr),hl
  ld a,$52
  ld (.vib_direction),a
  jp .next

.glide_up:
  ld (vib_max_addr),hl
  ld (vib_offset_addr),de
  call hl_div_c
  ld (vib_change_addr),hl
  ld a,$5a
  ld (.vib_direction),a
  jr .next

.not_glide:
  djnz .not_vib_properties

  ld a,.vib - .vib_reljump_org
  ld (vib_reljump_addr),a
  ld a,$01
  ld (arp_count_addr),a
  ld (arp_count2_addr),a

  ld a,(hl)
  inc hl
  ld (vib_delay_reset_addr),a
  ld a,(hl)
  inc hl
  ld (vib_difference_addr),a
  ld a,(hl)
  inc hl
  ld (vib_speed_addr),a
  jp .next_command

.not_vib_properties:
  djnz .not_arp_count

  ld a,(hl)
  inc hl
  and $1f
  jr nz,.arp_not_0
  ld a,$20
.arp_not_0:
  ld (arp_count_addr),a
  ld (arp_count2_addr),a
  xor a
  ld (vib_reljump_addr),a
  jp .next_command

.not_arp_count:
  djnz .not_rest

  ld a,(hl)
  inc hl
  ld (rest_length_addr),a
  jr .next

.not_rest:
  djnz .not_uncond_jump

  ld e,(hl)
  inc hl
  ld d,(hl)
  ld hl,($d8a2)
  add hl,de
relocate_a =: $ + 1
  ld (channel_pointer_addr),hl
  jp .next_command

.not_uncond_jump:
  djnz .not_djnz

  ld e,(hl)
  inc hl
  ex de,hl
  ld h,$da
  dec (hl)
  ex de,hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  jp nz,.next_command
  ex de,hl
  ld (channel_pointer_addr),hl
  jp .next_command

.not_djnz:
  djnz .not_setvalue

  ld e,(hl)
  inc hl
  ld d,$da
  ld a,(hl)
  inc hl
  ld (de),a
  jp .next_command

.not_setvalue:
  dec hl

.next:
ch_driver.size := $ - $$
load ch_driver.data: ch_driver.size from $$
end virtual

repeat 1,x:ch_driver.size
  display "driver size per channel: ",`x,10
end repeat

drumbass:
virtual at $c6ec + 4 * ch_driver.size
  jp $c6ec
  drumbass.size := $ - $$
  load drumbass.data: drumbass.size from $$
end virtual
db drumbass.data
